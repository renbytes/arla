--- FILE: simulations/schelling_sim/actions.py ---

# simulations/schelling_sim/actions.py

import random
from typing import Any, Dict, List

from agent_core.agents.actions.action_interface import ActionInterface
from agent_core.agents.actions.action_registry import action_registry
from agent_core.agents.actions.base_action import ActionOutcome
from agent_core.core.ecs.abstractions import SimulationState

# --- FIX: Import the new, separated components ---
from .components import PositionComponent, SatisfactionComponent
from .environment import SchellingGridEnvironment


@action_registry.register
class MoveToEmptyCellAction(ActionInterface):
    """
    An action that allows an unsatisfied agent to move to a random empty cell.
    """

    @property
    def action_id(self) -> str:
        """A unique string identifier for the action."""
        return "move_to_empty_cell"

    @property
    def name(self) -> str:
        """A human-readable name for the action."""
        return "Move to Empty Cell"

    def get_base_cost(self, simulation_state: SimulationState) -> float:
        """The base time budget cost to perform the action."""
        return 1.0

    def generate_possible_params(
        self, entity_id: str, simulation_state: SimulationState, current_tick: int
    ) -> List[Dict[str, Any]]:
        """
        Generates a move parameter if the agent is unsatisfied and there are
        empty cells available.
        """
        # --- FIX: Use the SatisfactionComponent to check the agent's state ---
        satisfaction_comp = simulation_state.get_component(entity_id, SatisfactionComponent)

        # Only generate a move action if the agent is unsatisfied.
        if not satisfaction_comp or satisfaction_comp.is_satisfied:
            return []

        env = simulation_state.environment
        if not isinstance(env, SchellingGridEnvironment):
            return []

        empty_cells = env.get_empty_cells()
        if not empty_cells:
            return []

        # The agent will move to a random empty cell.
        target_cell = random.choice(empty_cells)
        return [{"target_x": target_cell[0], "target_y": target_cell[1]}]

    def execute(
        self,
        entity_id: str,
        simulation_state: SimulationState,
        params: Dict[str, Any],
        current_tick: int,
    ) -> ActionOutcome:
        """
        Signals the intent to move. The actual move logic is handled by the
        MovementSystem.
        """
        pos_comp = simulation_state.get_component(entity_id, PositionComponent)
        if not pos_comp:
            return ActionOutcome(success=False, message="Agent has no PositionComponent.", base_reward=-0.1)

        target_pos = (params.get("target_x"), params.get("target_y"))
        return ActionOutcome(
            success=True,
            message=f"Agent {entity_id} moves from {pos_comp.position} to {target_pos}.",
            base_reward=1.0,
        )

    def get_feature_vector(
        self, entity_id: str, simulation_state: SimulationState, params: Dict[str, Any]
    ) -> List[float]:
        """Generates a feature vector for this action (not used in this model)."""
        return [1.0]


--- FILE: simulations/schelling_sim/components.py ---

# simulations/schelling_sim/components.py

from typing import Any, Dict, List, Tuple

from agent_core.core.ecs.component import Component


class PositionComponent(Component):
    """Stores an entity's x, y coordinates in the grid world."""

    def __init__(self, x: int = 0, y: int = 0) -> None:
        self.x = x
        self.y = y
        self.previous_x = x
        self.previous_y = y

    def move_to(self, new_x: int, new_y: int) -> None:
        """Update position and track previous location."""
        self.previous_x, self.previous_y = self.x, self.y
        self.x, self.y = new_x, new_y

    @property
    def position(self) -> Tuple[int, int]:
        """Returns the current position as a tuple."""
        return (self.x, self.y)

    @property
    def previous_position(self) -> Tuple[int, int]:
        """Returns the previous position as a tuple."""
        return (self.previous_x, self.previous_y)

    def to_dict(self) -> Dict[str, Any]:
        """Serializes the component's data to a dictionary."""
        return {
            "x": self.x,
            "y": self.y,
            "previous_x": self.previous_x,
            "previous_y": self.previous_y,
        }

    def validate(self, entity_id: str) -> Tuple[bool, List[str]]:
        """Validates the component's internal state."""
        errors: List[str] = []
        if not isinstance(self.x, int) or not isinstance(self.y, int):
            errors.append("Position coordinates must be integers")
        return len(errors) == 0, errors


class GroupComponent(Component):
    """Stores the agent's group or type identifier."""

    def __init__(self, agent_type: int) -> None:
        self.agent_type = agent_type

    def to_dict(self) -> Dict[str, Any]:
        """Serializes the component's data to a dictionary."""
        return {"agent_type": self.agent_type}

    def validate(self, entity_id: str) -> Tuple[bool, List[str]]:
        """Validates the component's internal state."""
        return True, []


class SatisfactionComponent(Component):
    """Stores an agent's satisfaction state and threshold."""

    def __init__(self, satisfaction_threshold: float) -> None:
        self.satisfaction_threshold = satisfaction_threshold
        self.is_satisfied: bool = False

    def to_dict(self) -> Dict[str, Any]:
        """Serializes the component's data to a dictionary."""
        return {
            "satisfaction_threshold": self.satisfaction_threshold,
            "is_satisfied": self.is_satisfied,
        }

    def validate(self, entity_id: str) -> Tuple[bool, List[str]]:
        """Validates the component's internal state."""
        errors: List[str] = []
        if not 0.0 <= self.satisfaction_threshold <= 1.0:
            errors.append("satisfaction_threshold must be between 0.0 and 1.0.")
        return len(errors) == 0, errors


--- FILE: simulations/schelling_sim/environment.py ---

# simulations/schelling_sim/environment.py

from typing import Any, Dict, List, Optional, Set, Tuple

from agent_core.environment.interface import EnvironmentInterface

from .components import PositionComponent


class SchellingGridEnvironment(EnvironmentInterface):
    """
    A grid-based environment for the Schelling segregation model.

    This environment implements toroidal wrapping, meaning the grid's edges
    connect to each other.

    Args:
        width (int): The width of the grid.
        height (int): The height of the grid.

    Sample Usage:
        env = SchellingGridEnvironment(width=20, height=20)
        env.add_entity("agent_1", (5, 5))
        neighbors = env.get_neighbors((5, 5))
    """

    def __init__(self, width: int, height: int) -> None:
        self.width = width
        self.height = height
        self.grid: Dict[Tuple[int, int], str] = {}
        self.agent_positions: Dict[str, Tuple[int, int]] = {}

    def initialize_from_state(self, simulation_state: Any, agent_components: Dict[str, Dict[Any, Any]]) -> None:
        """Populates the grid based on the initial state of agent components."""
        self.grid.clear()
        self.agent_positions.clear()
        for agent_id, components in agent_components.items():
            pos_comp = components.get(PositionComponent)
            if pos_comp:
                self.add_entity(agent_id, pos_comp.position)

    def add_entity(self, entity_id: str, position: Tuple[int, int]) -> None:
        """Adds an entity to the grid at a given position."""
        self.grid[position] = entity_id
        self.agent_positions[entity_id] = position

    def move_entity(self, entity_id: str, from_pos: Tuple[int, int], to_pos: Tuple[int, int]) -> bool:
        """Moves an entity from one position to another."""
        if self.grid.get(to_pos) is not None:
            return False  # Target cell is occupied
        if self.grid.get(from_pos) != entity_id:
            return False  # Entity not at the specified starting position

        del self.grid[from_pos]
        self.grid[to_pos] = entity_id
        self.agent_positions[entity_id] = to_pos
        return True

    def get_neighbors_of_position(self, position: Tuple[int, int]) -> Dict[Tuple[int, int], str]:
        """
        Gets all neighboring entities for a given position with toroidal wrapping.
        """
        x, y = position
        neighbors = {}
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue

                # Apply toroidal wrapping
                nx, ny = (x + dx) % self.width, (y + dy) % self.height
                neighbor_pos = (nx, ny)

                if neighbor_pos in self.grid:
                    neighbors[neighbor_pos] = self.grid[neighbor_pos]
        return neighbors

    def get_empty_cells(self) -> List[Tuple[int, int]]:
        """Returns a list of all unoccupied cells on the grid."""
        all_cells = set((x, y) for x in range(self.width) for y in range(self.height))
        occupied_cells = set(self.grid.keys())
        return list(all_cells - occupied_cells)

    def distance(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:
        """Calculates the toroidal distance between two points."""
        dx = abs(pos1[0] - pos2[0])
        dy = abs(pos1[1] - pos2[1])

        # Account for wrapping
        wrapped_dx = min(dx, self.width - dx)
        wrapped_dy = min(dy, self.height - dy)

        return float(wrapped_dx + wrapped_dy)

    def to_dict(self) -> Dict[str, Any]:
        """Serializes the environment's state to a dictionary."""
        return {
            "width": self.width,
            "height": self.height,
            # Convert tuple keys to string for JSON compatibility
            "grid": {str(k): v for k, v in self.grid.items()},
            "agent_positions": self.agent_positions,
        }

    def restore_from_dict(self, data: Dict[str, Any]) -> None:
        """Restores the environment's state from a dictionary."""
        self.width = data["width"]
        self.height = data["height"]
        # Convert string keys back to tuple
        self.grid = {eval(k): v for k, v in data["grid"].items()}
        self.agent_positions = data["agent_positions"]

    # --- Other required methods from the interface ---
    def get_valid_positions(self) -> List[Any]:
        return list((x, y) for x in range(self.width) for y in range(self.height))

    def get_neighbors(self, position: Any) -> List[Any]:
        return list(self.get_neighbors_of_position(position).keys())

    def can_move(self, from_pos: Any, to_pos: Any) -> bool:
        return self.grid.get(to_pos) is None

    def is_valid_position(self, position: Any) -> bool:
        return 0 <= position[0] < self.width and 0 <= position[1] < self.height

    def get_entities_at_position(self, position: Any) -> Set[str]:
        agent_id = self.grid.get(position)
        return {agent_id} if agent_id else set()

    def get_entities_in_radius(self, center: Any, radius: int) -> List[Tuple[str, Any]]:
        # Not required for this simulation, but must be implemented
        return []

    def update_entity_position(self, entity_id: str, old_pos: Optional[Any], new_pos: Any) -> None:
        if old_pos:
            self.move_entity(entity_id, old_pos, new_pos)
        else:
            self.add_entity(entity_id, new_pos)

    def remove_entity(self, entity_id: str) -> None:
        if entity_id in self.agent_positions:
            pos = self.agent_positions.pop(entity_id)
            if pos in self.grid:
                del self.grid[pos]


--- FILE: simulations/schelling_sim/loader.py ---

# simulations/schelling_sim/loader.py

import json
import random
from typing import cast

from agent_core.core.ecs.component import TimeBudgetComponent
from agent_core.simulation.scenario_loader_interface import ScenarioLoaderInterface

from .components import GroupComponent, PositionComponent, SatisfactionComponent
from .environment import SchellingGridEnvironment


class SchellingScenarioLoader(ScenarioLoaderInterface):
    """
    Loads a scenario for the Schelling segregation model.

    This loader reads a JSON scenario file to configure the simulation grid
    and populate it with agents of different types at random locations.
    """

    def __init__(self, simulation_state, scenario_path: str):
        self.simulation_state = simulation_state
        self.scenario_path = scenario_path

    def load(self) -> None:
        """
        Loads the scenario, initializes the environment, and creates agents.
        """
        with open(self.scenario_path, "r") as f:
            scenario_data = json.load(f)

        config = self.simulation_state.config
        num_agents = scenario_data.get("num_agents", 100)
        group_ratio = scenario_data.get("group_ratio", 0.5)
        satisfaction_threshold = config.simulation.get("satisfaction_threshold", 0.4)

        # The environment is now passed in, so we just ensure it's the correct type
        environment = cast(SchellingGridEnvironment, self.simulation_state.environment)
        if not environment:
            raise ValueError("Environment not initialized in SimulationState.")

        # Create agents
        locations = random.sample(environment.get_valid_positions(), num_agents)
        num_group_1 = int(num_agents * group_ratio)

        for i in range(num_agents):
            agent_id = f"agent_{i}"
            agent_type = 1 if i < num_group_1 else 2
            position = locations[i]

            self.simulation_state.add_entity(agent_id)
            self.simulation_state.add_component(agent_id, PositionComponent(x=position[0], y=position[1]))

            self.simulation_state.add_component(agent_id, GroupComponent(agent_type=agent_type))
            self.simulation_state.add_component(
                agent_id, SatisfactionComponent(satisfaction_threshold=satisfaction_threshold)
            )

            self.simulation_state.add_component(agent_id, TimeBudgetComponent(initial_time_budget=1000))

        environment.initialize_from_state(self.simulation_state, self.simulation_state.entities)


--- FILE: simulations/schelling_sim/systems.py ---

# simulations/schelling_sim/systems.py

from typing import Any, Dict, List, Type

from agent_core.core.ecs.component import Component
from agent_engine.simulation.system import System

from .components import GroupComponent, PositionComponent, SatisfactionComponent
from .environment import SchellingGridEnvironment


class SatisfactionSystem(System):
    """
    Calculates and updates the satisfaction state of each agent based on its
    neighbors.
    """

    REQUIRED_COMPONENTS: List[Type[Component]] = [
        PositionComponent,
        GroupComponent,
        SatisfactionComponent,
    ]

    async def update(self, current_tick: int) -> None:
        """
        Iterates through all Schelling agents and updates their `is_satisfied`
        status based on the types of their neighbors.
        """
        env = self.simulation_state.environment
        if not isinstance(env, SchellingGridEnvironment):
            return

        all_agents = self.simulation_state.get_entities_with_components(
            self.REQUIRED_COMPONENTS
        )

        for agent_id, components in all_agents.items():
            pos_comp = components.get(PositionComponent)
            group_comp = components.get(GroupComponent)
            satisfaction_comp = components.get(SatisfactionComponent)

            if not all([pos_comp, group_comp, satisfaction_comp]):
                continue

            neighbors = env.get_neighbors_of_position(pos_comp.position)
            num_neighbors = len(neighbors)

            # An agent with no neighbors is considered satisfied.
            if num_neighbors == 0:
                satisfaction_comp.is_satisfied = True
                continue

            # Count neighbors of the same group type.
            same_type_neighbors = 0
            for neighbor_id in neighbors.values():
                neighbor_group_comp = self.simulation_state.get_component(
                    neighbor_id, GroupComponent
                )
                if (
                    neighbor_group_comp
                    and neighbor_group_comp.agent_type == group_comp.agent_type
                ):
                    same_type_neighbors += 1

            # The agent is satisfied if the ratio of same-type neighbors
            # to total neighbors meets or exceeds its personal threshold.
            satisfaction_ratio = same_type_neighbors / num_neighbors
            is_now_satisfied = (
                satisfaction_ratio >= satisfaction_comp.satisfaction_threshold
            )
            satisfaction_comp.is_satisfied = is_now_satisfied


class MovementSystem(System):
    """
    Listens for move events and executes them by updating the environment
    and the agent's PositionComponent.
    """

    def __init__(
        self,
        simulation_state: Any,
        config: Dict[str, Any],
        cognitive_scaffold: Any,
    ) -> None:
        super().__init__(simulation_state, config, cognitive_scaffold)
        if self.event_bus:
            self.event_bus.subscribe(
                "execute_move_to_empty_cell_action", self.on_move_execute
            )

    def on_move_execute(self, event_data: Dict[str, Any]) -> None:
        """Handles the execution of a move action."""
        entity_id = event_data["entity_id"]
        params = event_data["action_plan_component"].params
        pos_comp = self.simulation_state.get_component(entity_id, PositionComponent)
        env = self.simulation_state.environment

        if not all([pos_comp, isinstance(env, SchellingGridEnvironment)]):
            self._publish_outcome(event_data, success=False)
            return

        from_pos = pos_comp.position
        to_pos = (params["target_x"], params["target_y"])

        if env.move_entity(entity_id, from_pos, to_pos):
            pos_comp.move_to(to_pos[0], to_pos[1])
            self._publish_outcome(event_data, success=True)
        else:
            self._publish_outcome(event_data, success=False)

    def _publish_outcome(self, event_data: Dict[str, Any], success: bool) -> None:
        """Publishes the result of the action execution to the event bus."""
        if hasattr(event_data.get("action_outcome"), "success"):
            event_data["action_outcome"].success = success
        if self.event_bus:
            self.event_bus.publish("action_outcome_ready", event_data)

    async def update(self, current_tick: int) -> None:
        """This system is purely event-driven."""
        pass


--- FILE: simulations/schelling_sim/config/config.yml ---

simulation_package: "simulations.schelling_sim"

simulation:
  steps: 200 # Increased steps to better see the effect
  log_directory: "data/logs/schelling_sim"
  random_seed: 42
  satisfaction_threshold: 0.4

environment:
  class: "simulations.schelling_sim.environment.SchellingGridEnvironment"
  params:
    width: 50
    height: 50

scenario_loader:
  class: "simulations.schelling_sim.loader.SchellingScenarioLoader"

action_generator:
  class: "simulations.schelling_sim.run.SchellingActionGenerator"

# Defines the class that selects an action for an agent to perform.
decision_selector:
  class: "simulations.schelling_sim.run.SchellingDecisionSelector"

# Defines the factory for creating components when loading a saved state.
component_factory:
  class: "simulations.schelling_sim.run.SchellingComponentFactory"

# A list of all system modules to be loaded and registered.
systems:
  - "simulations.schelling_sim.systems.SatisfactionSystem"
  - "simulations.schelling_sim.systems.MovementSystem"

# A list of all action modules to be loaded.
actions:
  - "simulations.schelling_sim.actions"

# Updated logging to reflect the new component names
logging:
  components_to_log:
    - "simulations.schelling_sim.components.PositionComponent"
    - "simulations.schelling_sim.components.GroupComponent"
    - "simulations.schelling_sim.components.SatisfactionComponent"

--- FILE: tests/simulations/schelling_sim/test_systems.py ---

# tests/simulations/schelling_sim/test_systems.py

import asyncio
from unittest.mock import Mock

import pytest

from simulations.schelling_sim.components import (
    GroupComponent,
    PositionComponent,
    SatisfactionComponent,
)
from simulations.schelling_sim.systems import SatisfactionSystem


@pytest.fixture
def mock_simulation_state():
    """Provides a mock SimulationState for testing."""
    state = Mock()
    state.environment = Mock()
    state.environment.get_neighbors_of_position = Mock()
    state.get_component = Mock()
    state.get_entities_with_components = Mock()
    return state


@pytest.fixture
def satisfaction_system(mock_simulation_state):
    """Provides an instance of the SatisfactionSystem with a mock state."""
    # This system does not depend on config or the scaffold
    return SatisfactionSystem(mock_simulation_state, None, None)


def test_update_satisfaction_becomes_satisfied(satisfaction_system, mock_simulation_state):
    """Tests an agent becomes satisfied when its neighbor ratio meets the threshold."""
    # Arrange
    agent_id = "agent_A"
    pos_comp = PositionComponent(x=1, y=1)
    group_comp = GroupComponent(agent_type=1)
    satisfaction_comp = SatisfactionComponent(satisfaction_threshold=0.5)
    satisfaction_comp.is_satisfied = False

    # Store all components in a structure that mimics the real SimulationState
    all_comps = {
        "agent_A": {
            PositionComponent: pos_comp,
            GroupComponent: group_comp,
            SatisfactionComponent: satisfaction_comp,
        },
        "neighbor1": {GroupComponent: GroupComponent(agent_type=1)},
        "neighbor2": {GroupComponent: GroupComponent(agent_type=1)},
        "neighbor3": {GroupComponent: GroupComponent(agent_type=2)},
    }

    # Configure mocks to use the component store
    mock_simulation_state.get_entities_with_components.return_value = {
        agent_id: all_comps[agent_id]
    }
    mock_simulation_state.environment.get_neighbors_of_position.return_value = {
        (1, 0): "neighbor1", (1, 2): "neighbor2", (0, 1): "neighbor3"
    }
    mock_simulation_state.get_component.side_effect = lambda eid, ctype: all_comps.get(
        eid, {}
    ).get(ctype)

    # Act
    asyncio.run(satisfaction_system.update(current_tick=1))

    # Assert (2 out of 3 neighbors are the same type = 66.7% > 50% threshold)
    assert satisfaction_comp.is_satisfied is True


def test_update_satisfaction_becomes_unsatisfied(satisfaction_system, mock_simulation_state):
    """Tests an agent becomes unsatisfied when its neighbor ratio falls below the threshold."""
    # Arrange
    agent_id = "agent_A"
    pos_comp = PositionComponent(x=1, y=1)
    group_comp = GroupComponent(agent_type=1)
    satisfaction_comp = SatisfactionComponent(satisfaction_threshold=0.5)
    satisfaction_comp.is_satisfied = True

    all_comps = {
        "agent_A": {
            PositionComponent: pos_comp,
            GroupComponent: group_comp,
            SatisfactionComponent: satisfaction_comp,
        },
        "neighbor1": {GroupComponent: GroupComponent(agent_type=1)},
        "neighbor2": {GroupComponent: GroupComponent(agent_type=2)},
        "neighbor3": {GroupComponent: GroupComponent(agent_type=2)},
    }
    
    mock_simulation_state.get_entities_with_components.return_value = {
        agent_id: all_comps[agent_id]
    }
    mock_simulation_state.environment.get_neighbors_of_position.return_value = {
        (1, 0): "neighbor1", (1, 2): "neighbor2", (0, 1): "neighbor3"
    }
    mock_simulation_state.get_component.side_effect = lambda eid, ctype: all_comps.get(
        eid, {}
    ).get(ctype)

    # Act
    asyncio.run(satisfaction_system.update(current_tick=1))

    # Assert (1 out of 3 neighbors are the same type = 33.3% < 50% threshold)
    assert satisfaction_comp.is_satisfied is False


def test_update_isolated_agent_is_satisfied(satisfaction_system, mock_simulation_state):
    """Tests that an agent with no neighbors is always satisfied."""
    # Arrange
    agent_id = "agent_A"
    pos_comp = PositionComponent(x=1, y=1)
    group_comp = GroupComponent(agent_type=1)
    satisfaction_comp = SatisfactionComponent(satisfaction_threshold=0.5)
    satisfaction_comp.is_satisfied = False

    all_comps = {
        "agent_A": {
            PositionComponent: pos_comp,
            GroupComponent: group_comp,
            SatisfactionComponent: satisfaction_comp,
        }
    }

    mock_simulation_state.get_entities_with_components.return_value = {
        agent_id: all_comps[agent_id]
    }
    mock_simulation_state.environment.get_neighbors_of_position.return_value = {}

    # Act
    asyncio.run(satisfaction_system.update(current_tick=1))

    # Assert
    assert satisfaction_comp.is_satisfied is True


def test_update_agent_with_high_threshold_becomes_unsatisfied(
    satisfaction_system, mock_simulation_state
):
    """Tests that an agent's specific threshold is respected."""
    # Arrange
    agent_id = "agent_A"
    pos_comp = PositionComponent(x=1, y=1)
    group_comp = GroupComponent(agent_type=1)
    satisfaction_comp = SatisfactionComponent(satisfaction_threshold=0.7)
    satisfaction_comp.is_satisfied = True

    all_comps = {
        "agent_A": {
            PositionComponent: pos_comp,
            GroupComponent: group_comp,
            SatisfactionComponent: satisfaction_comp,
        },
        "neighbor1": {GroupComponent: GroupComponent(agent_type=1)},
        "neighbor2": {GroupComponent: GroupComponent(agent_type=1)},
        "neighbor3": {GroupComponent: GroupComponent(agent_type=2)},
    }
    
    mock_simulation_state.get_entities_with_components.return_value = {
        agent_id: all_comps[agent_id]
    }
    mock_simulation_state.environment.get_neighbors_of_position.return_value = {
        (1, 0): "neighbor1", (1, 2): "neighbor2", (0, 1): "neighbor3"
    }
    mock_simulation_state.get_component.side_effect = lambda eid, ctype: all_comps.get(
        eid, {}
    ).get(ctype)

    # Act
    asyncio.run(satisfaction_system.update(current_tick=1))

    # Assert (2 out of 3 neighbors are same type = 66.7% < 70% threshold)
    assert satisfaction_comp.is_satisfied is False


